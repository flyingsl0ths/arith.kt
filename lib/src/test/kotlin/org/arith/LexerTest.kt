/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package org.arith

import kotlin.test.Test
import kotlin.test.assertEquals

@Test
fun givenAnEmptySourceReturnsAnEOFToken() {
    val lexer = Lexer("")
    val (token, lexerr) = lex(lexer)

    assertEquals(lexerr, lexer)

    assertEquals(token, Token(null, TokenType.EOF, 0))
}

@Test
fun givenWhiteSpaceIgnoresIt() {
    val lexer = Lexer("   1")
    val (token, lexerr) = lex(lexer)

    assertEquals(lexerr.source, "")
    assertEquals(lexerr.column, 4)

    assertEquals(token, Token("1", TokenType.NUM, 3))
}

@Test
fun givenAWholeNumberReturnsAWholeNumber() {
    val lexer = Lexer("1")
    val (token, lexerr) = lex(lexer)

    assertEquals(lexerr.source, "")
    assertEquals(lexerr.column, 1)

    assertEquals(token, Token("1", TokenType.NUM, 0))
}

@Test
fun givenADecimalReturnsADecimal() {
    val lexer = Lexer("1.0")
    val (token, lexerr) = lex(lexer)

    assertEquals(lexerr.source, "")
    assertEquals(lexerr.column, 3)

    assertEquals(token, Token("1.0", TokenType.NUM, 0))
}

@Test
fun givenASourceContainingAllSingleCharsReturnsTheAppropriateTokens() {
    fun opPrecedence(lexeme: String): Precedence =
            when (lexeme) {
                "+", "-" -> Precedence.TERM
                "*", "/", "%" -> Precedence.FACTOR
                "!", "^" -> Precedence.FACTOR
                else -> Precedence.NONE
            }

    fun tokenTypeOfSingle(lexeme: String) =
            when (lexeme) {
                "!" -> TokenType.BANG
                "*" -> TokenType.STAR
                "^" -> TokenType.POW
                "+" -> TokenType.PLUS
                "-" -> TokenType.MINUS
                "/" -> TokenType.SLASH
                "%" -> TokenType.MOD
                "(" -> TokenType.LEFT_PAREN
                ")" -> TokenType.RIGHT_PAREN
                "," -> TokenType.COMMA
                else -> TokenType.ERROR
            }

    "!*^+-%/(,)".forEach {
        val source = it.toString()

        val prec = opPrecedence(source)

        val lexer = Lexer(source)
        val (token, lexerr) = lex(lexer)

        assertEquals(lexerr.source, "")
        assertEquals(lexerr.column, 1)

        assertEquals(
                token,
                Token(
                        source,
                        tokenTypeOfSingle(source),
                        0,
                        prec,
                        source != "^" && prec != Precedence.NONE
                )
        )
    }
}

@Test
fun givenAnInvalidDecimalReturnsAnAppropriateError() {
    val lexer = Lexer("1..0")
    val (token, lexerr) = lex(lexer)

    assertEquals(lexerr.source, "1..0")
    assertEquals(lexerr.column, 0)

    assertEquals(
            token,
            Token(
                    "Syntax error: floating point number cannot contain more than one '.'",
                    TokenType.ERROR,
                    0,
                    Precedence.NONE
            )
    )
}

@Test
fun givenAnKnownFunctionNameReturnsAnAppropriateToken() {
    listOf(
                    "abs",
                    "acos",
                    "acot",
                    "acsc",
                    "asec",
                    "asin",
                    "atan",
                    "ceil",
                    "cos",
                    "cosh",
                    "cot",
                    "csc",
                    "exp",
                    "exp2",
                    "ln",
                    "log",
                    "log10",
                    "rad",
                    "round",
                    "sec",
                    "sin",
                    "sinh",
                    "sqrt",
                    "tan",
                    "tanh",
                    "deg",
                    "floor",
                    "nroot"
            )
            .forEach {
                val lexer = Lexer(it)
                val (token, lexerr) = lex(lexer)

                assertEquals(lexerr.source, "")
                assertEquals(lexerr.column, it.length)

                assertEquals(
                        token.copy(function = null),
                        Token(it, TokenType.FUNCTION, 0, Precedence.NONE)
                )
            }
}

@Test
fun givenAnUnknownFunctionNameReturnsAnError() {
    val lexer = Lexer("abc")
    val (token, lexerr) = lex(lexer)

    assertEquals(lexerr.source, "abc")
    assertEquals(lexerr.column, 0)

    assertEquals(token, Token("Unknown function name", TokenType.ERROR, 0, Precedence.NONE))
}

@Test
fun givenAnUnknownLexemeReturnsAnError() {
    val lexer = Lexer(">")
    val (token, lexerr) = lex(lexer)

    assertEquals(lexerr.source, ">")
    assertEquals(lexerr.column, 0)

    assertEquals(token, Token("Unknown token", TokenType.ERROR, 0, Precedence.NONE))
}

@Test
fun givenANegativeNumberReturnsTheAppropriateTokens() {
    val lexer = Lexer("-10")
    val (token, lexerr) = lex(lexer)

    assertEquals(lexerr.source, "10")
    assertEquals(lexerr.column, 1)

    assertEquals(token, Token("-", TokenType.MINUS, 0, Precedence.UNARY, true))
}

@Test
fun givenANegativeNumberBetweenAnExprReturnsTheAppropriateTokens() {
    val lexer = Lexer("+ -10")
    val (token, lexerr) = lex(lexer)

    assertEquals(lexerr.source, " -10")
    assertEquals(lexerr.column, 1)

    assertEquals(token, Token("+", TokenType.PLUS, 0, Precedence.TERM, true))

    val (tokenn, lexerrr) = lex(lexerr)

    assertEquals(lexerrr.source, "10")
    assertEquals(lexerrr.column, 3)

    assertEquals(tokenn, Token("-", TokenType.MINUS, 2, Precedence.UNARY, true))
}
